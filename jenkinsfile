// Purpose: Build, test, scan, and push a C# (.NET) Dockerized app using the dotnet agent.
pipeline {
    agent { label 'dotnet' }

    environment { // Key Environment Variables:
        DOCKER_REGISTRY = 'docker.io' // Where to push the image (e.g., Docker Hub)
        DOCKER_REPOSITORY = 'wahbamousa/csharp-sample-app' // App-specific repo on Docker Hub
        DOCKER_CREDENTIALS_ID = 'dockerhub-credentials' // Jenkins credential for DockerHub login
        SONAR_PROJECT_KEY = 'csharp-sample-app' // Key for SonarQube scan
        APP_VERSION = "${env.BUILD_NUMBER}"
        DOTNET_CLI_HOME = "/tmp/dotnet_cli_home" // Isolated CLI cache path (to avoid permission issues)
        DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
    }

    stages { // Pipeline Stages:
        stage('Checkout') {
            steps { checkout scm } // Pulls code from GitHub (checkout scm)
        }

        stage('Set Variables') { // Sets GIT_COMMIT_HASH, DOCKER_IMAGE_TAG, and reads project version
            steps {
                script {
                    env.GIT_COMMIT_HASH = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    env.DOCKER_IMAGE_TAG = "${GIT_COMMIT_HASH}-${BUILD_NUMBER}"
                    env.DOCKER_IMAGE_VERSION = "${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:${DOCKER_IMAGE_TAG}"
                    env.DOCKER_IMAGE_LATEST = "${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:latest"
                    env.PROJECT_VERSION = sh(script: '''
                        grep -oP '(?<=<Version>).*(?=</Version>)' Directory.Build.props || echo "1.0.0"
                    ''', returnStdout: true).trim()
                }
            }
        }

        stage('Restore & Build') { // Uses dotnet restore and dotnet build
            steps {
                sh 'dotnet restore --no-cache'
                sh 'dotnet build --no-restore -c Release'
            }
        }

        stage('Test & Coverage') { // Runs unit tests with coverage (coverlet) and generates HTML report
            steps {
                sh 'dotnet test --no-build --no-restore -c Release --logger "trx;LogFileName=test-results.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=./coverage/'
            }
            post {
                always {
                    xunit tools: [MSTest(pattern: '**/TestResults/*.trx')]
                    sh 'dotnet reportgenerator -reports:"./coverage/coverage.opencover.xml" -targetdir:"./coverage/report" -reporttypes:Html'
                    publishHTML(target: [
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: './coverage/report',
                        reportFiles: 'index.html',
                        reportName: 'Code Coverage Report'
                    ])
                }
            }
        }

        stage('SonarQube Analysis') { // Sends analysis and test coverage to SonarQube
            steps {
                withSonarQubeEnv('SonarQube') {
                    sh """
                        dotnet sonarscanner begin /k:"${SONAR_PROJECT_KEY}" /n:"${SONAR_PROJECT_KEY}" /d:sonar.cs.opencover.reportsPaths="./coverage/coverage.opencover.xml"
                        dotnet build --no-restore -c Release
                        dotnet sonarscanner end
                    """
                }
            }
        }

        stage('Quality Gate') { // Waits for SonarQube gate result
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('Publish') { // Publishes the final app binaries to ./publish
            steps {
                sh 'dotnet publish -c Release -o ./publish'
            }
        }

        stage('Build Docker Image') { // Builds Docker image with build args and tags it
            steps {
                sh """
                    docker build -t ${DOCKER_IMAGE_VERSION} \
                      --build-arg APP_VERSION=${PROJECT_VERSION} \
                      --build-arg BUILD_NUMBER=${BUILD_NUMBER} \
                      --build-arg GIT_COMMIT=${GIT_COMMIT_HASH} \
                      --no-cache -f Dockerfile .
                    docker tag ${DOCKER_IMAGE_VERSION} ${DOCKER_IMAGE_LATEST}
                """
            }
        }

        stage('Scan Docker Image') { // Runs Trivy for security scanning (HIGH+CRITICAL)
            steps {
                sh "trivy image --severity HIGH,CRITICAL ${DOCKER_IMAGE_VERSION}"
            }
        }

        stage('Push Docker Image') { // Pushes both versioned and latest tags to DockerHub (only on main)
            when { branch 'main' }
            steps {
                withCredentials([usernamePassword(credentialsId: DOCKER_CREDENTIALS_ID, usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh """
                        echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin ${DOCKER_REGISTRY}
                        docker push ${DOCKER_IMAGE_VERSION}
                        docker push ${DOCKER_IMAGE_LATEST}
                    """
                }
            }
        }

        stage('Deploy (Placeholder)') { // Placeholder for deployment step
            when { branch 'main' }
            steps {
                echo 'Deploy to dev server or K8s here...'
            }
        }
    }

    post {
        always { // Cleanup images + Docker cache
            sh """ 
                docker rmi ${DOCKER_IMAGE_VERSION} || true
                docker rmi ${DOCKER_IMAGE_LATEST} || true
                docker system prune -f || true
            """
            archiveArtifacts artifacts: 'publish/**/*', fingerprint: true // Archive published files
        }
    }
}
