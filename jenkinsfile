pipeline {
    agent { label 'dotnet' }

    environment {
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_REPOSITORY = 'wahbamousa/csharp-sample-app'
        DOCKER_CREDENTIALS_ID = 'dockerhub-credentials'
        SONAR_PROJECT_KEY = 'csharp-sample-app'
        APP_VERSION = "${env.BUILD_NUMBER}"
        DOTNET_CLI_HOME = "/tmp/dotnet_cli_home"
        DOTNET_CLI_TELEMETRY_OPTOUT = '1'
    }

    options {
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
    }

    stages {
        stage('Checkout') {
            steps { checkout scm }
        }

        stage('Set Variables') {
            steps {
                script {
                    env.GIT_COMMIT_HASH = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    env.DOCKER_IMAGE_TAG = "${GIT_COMMIT_HASH}-${BUILD_NUMBER}"
                    env.DOCKER_IMAGE_VERSION = "${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:${DOCKER_IMAGE_TAG}"
                    env.DOCKER_IMAGE_LATEST = "${DOCKER_REGISTRY}/${DOCKER_REPOSITORY}:latest"
                    env.PROJECT_VERSION = sh(script: '''
                        grep -oP '(?<=<Version>).*(?=</Version>)' Directory.Build.props || echo "1.0.0"
                    ''', returnStdout: true).trim()
                }
            }
        }

        stage('Restore & Build') {
            steps {
                sh 'dotnet restore --no-cache'
                sh 'dotnet build --no-restore -c Release'
            }
        }

        stage('Test & Coverage') {
            steps {
                sh 'dotnet test --no-build --no-restore -c Release --logger "trx;LogFileName=test-results.trx" /p:CollectCoverage=true /p:CoverletOutputFormat=opencover /p:CoverletOutput=./coverage/'
            }
            post {
                always {
                    xunit tools: [MSTest(pattern: '**/TestResults/*.trx')]
                    sh 'dotnet reportgenerator -reports:"./coverage/coverage.opencover.xml" -targetdir:"./coverage/report" -reporttypes:Html'
                    publishHTML(target: [
                        allowMissing: false,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: './coverage/report',
                        reportFiles: 'index.html',
                        reportName: 'Code Coverage Report'
                    ])
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                withSonarQubeEnv('SonarQube') {
                    sh """
                        dotnet sonarscanner begin /k:"${SONAR_PROJECT_KEY}" /n:"${SONAR_PROJECT_KEY}" /d:sonar.cs.opencover.reportsPaths="./coverage/coverage.opencover.xml"
                        dotnet build --no-restore -c Release
                        dotnet sonarscanner end
                    """
                }
            }
        }

        stage('Quality Gate') {
            steps {
                timeout(time: 10, unit: 'MINUTES') {
                    waitForQualityGate abortPipeline: true
                }
            }
        }

        stage('Publish') {
            steps {
                sh 'dotnet publish -c Release -o ./publish'
            }
        }

        stage('Build Docker Image') {
            steps {
                sh """
                    docker build -t ${DOCKER_IMAGE_VERSION} \
                      --build-arg APP_VERSION=${PROJECT_VERSION} \
                      --build-arg BUILD_NUMBER=${BUILD_NUMBER} \
                      --build-arg GIT_COMMIT=${GIT_COMMIT_HASH} \
                      --no-cache -f Dockerfile .
                    docker tag ${DOCKER_IMAGE_VERSION} ${DOCKER_IMAGE_LATEST}
                """
            }
        }

        stage('Scan Docker Image') {
            steps {
                sh "trivy image --severity HIGH,CRITICAL ${DOCKER_IMAGE_VERSION}"
            }
        }

        stage('Push Docker Image') {
            when { branch 'main' }
            steps {
                withCredentials([usernamePassword(credentialsId: DOCKER_CREDENTIALS_ID, usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                    sh """
                        echo "${DOCKER_PASSWORD}" | docker login -u "${DOCKER_USERNAME}" --password-stdin ${DOCKER_REGISTRY}
                        docker push ${DOCKER_IMAGE_VERSION}
                        docker push ${DOCKER_IMAGE_LATEST}
                    """
                }
            }
        }

        stage('Deploy (Placeholder)') {
            when { branch 'main' }
            steps {
                echo 'Deploy to dev server or K8s here...'
            }
        }
    }

    post {
        always {
            sh """
                docker rmi ${DOCKER_IMAGE_VERSION} || true
                docker rmi ${DOCKER_IMAGE_LATEST} || true
                docker system prune -f || true
            """
            archiveArtifacts artifacts: 'publish/**/*', fingerprint: true
        }
    }
}
